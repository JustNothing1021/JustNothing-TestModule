#!/system/bin/sh


# 常量定义
VERSION="0.3.1"
SERVICE_NAME="justnothing_xposed_method_cli"
METHODS_WORKDIR="/data/local/tmp/methods"
JAVA_CLIENT_JAR="/system/framework/methods-client.jar"
CLASS_NAME="com.justnothing.methodsclient.StreamClient"
TRANSACTION_EXECUTE_FILE="2"
TRANSACTION_EXECUTE_STREAM="3"
TRANSACTION_WRITE_PORT_FILE="4"
TRANSACTION_UPDATE_PORT="5"
TRANSACTION_EXPORT_CONTEXT="6"


SERVER_PORT_FILE="$METHODS_WORKDIR/methods_port"
LOG_FILE="$METHODS_WORKDIR/methods.log"
FILE_SESSION_WORKDIR="$METHODS_WORKDIR/execute_sessions"
PORT_UPDATE_SESSION_WORKDIR="$METHODS_WORKDIR/port_update_sessions"


# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# 定义颜色函数
color_red() { echo -e "${RED}$1${NC}"; }
color_green() { echo -e "${GREEN}$1${NC}"; }
color_yellow() { echo -e "${YELLOW}$1${NC}"; }
color_blue() { echo -e "${BLUE}$1${NC}"; }
color_purple() { echo -e "${PURPLE}$1${NC}"; }
color_cyan() { echo -e "${CYAN}$1${NC}"; }
color_white() { echo -e "${WHITE}$1${NC}"; }

# 日志函数
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    
    if [ "$DEBUG" = "1" ]; then
        case "$level" in
            "ERROR") color_red "[错误] $message" >&2 ;;
            "WARN") color_yellow "[警告] $message" >&2 ;;
            "INFO") color_green "[信息] $message" ;;
            "DEBUG") color_blue "[调试] $message" ;;
            *) color_blue "[调试] $message" ;;
        esac
    fi
}

# 检查服务
check_service() {
    log "INFO" "检查服务..."
    
    # 多种方式检查服务
    if service list 2>/dev/null | grep -q "$SERVICE_NAME"; then
        log "INFO" "服务在列表中"
        return 0
    fi
    
    if service check "$SERVICE_NAME" 2>/dev/null | grep -vq "not found"; then
        log "INFO" "服务检查通过"
        return 0
    fi
    
    # 尝试调用服务
    if service call "$SERVICE_NAME" 0 2>/dev/null | grep -q "Parcel"; then
        log "INFO" "服务调用成功"
        return 0
    fi
    
    log "ERROR" "服务检查失败"
    return 1
}

# 检查Java客户端
check_java_client() {
    if [ -f "$JAVA_CLIENT_JAR" ]; then
        log "DEBUG" "找到JAR客户端: $JAVA_CLIENT_JAR"
        return 0
    fi
    
    log "DEBUG" "未找到Java客户端"
    return 1
}

# 请求服务器更新端口文件
request_update_port_file() {
    log "INFO" "请求写入端口文件"
    log "DEBUG" "使用事务码${TRANSACTION_UPDATE_PORT}请求更新端口文件"
    
    # 调用服务
    local service_cmd="service call $SERVICE_NAME $TRANSACTION_WRITE_PORT_FILE"
    log "DEBUG" "执行: $service_cmd"

    # 执行服务调用
    eval "$service_cmd" >/dev/null 2>&1
    local exit_code=$?
    if [ $exit_code -eq 0 ]; then
        log "INFO" "端口文件更新请求成功"
        return 0
    else
        log "ERROR" "端口文件更新请求失败 (代码: $exit_code)"
        color_red "服务调用失败 (代码: $exit_code)" >&2
        return 1
    fi
}


# 执行Java客户端（直接传递参数）
execute_java_client_direct() {
    log "DEBUG" "执行Java客户端直接模式"
    
    # 检查Java客户端
    if ! check_java_client; then
        log "ERROR" "Java客户端未找到"
        color_red "Java客户端未找到: $JAVA_CLIENT_JAR" >&2
        return 1
    fi
    
    # 设置类路径
    local classpath="/system/framework/core-oj.jar:/system/framework/core-libart.jar:/system/framework/framework.jar:$JAVA_CLIENT_JAR"
    
    log "DEBUG" "执行Java命令: app_process -cp $classpath /system/bin $CLASS_NAME $@"
    
    # 执行Java客户端，直接传递所有参数
    /system/bin/app_process -cp "$classpath" /system/bin $CLASS_NAME "$@"
    return $?
}

# 执行Java客户端（带模式）
execute_java_client() {
    local mode="$1"
    local command="$2"
    log "DEBUG" "执行Java客户端[$mode]命令: $command"
    
    # 检查Java客户端
    if ! check_java_client; then
        log "ERROR" "Java客户端未找到: $JAVA_CLIENT_JAR"
        color_red "Java客户端未找到: $JAVA_CLIENT_JAR" >&2
        return 1
    fi
    
    # 设置类路径
    local classpath="/system/framework/core-oj.jar:/system/framework/core-libart.jar:/system/framework/framework.jar:$JAVA_CLIENT_JAR"
    
    # 根据模式构建参数
    local java_args=""
    if [ "$mode" = "socket" ]; then
        request_update_port_file
        java_args="--socket"
    elif [ "$mode" = "file" ]; then
        java_args="--file"
    fi
    
    log "DEBUG" "执行Java命令: app_process -cp $classpath /system/bin $CLASS_NAME $java_args \"$command\""
    
    # 执行Java客户端
    /system/bin/app_process -cp "$classpath" /system/bin $CLASS_NAME $java_args "$command"
    return $?
}

# 文件模式
execute_file_mode() {
    local command="$*"
    log "DEBUG" "执行文件模式命令: $command"
    
    # 创建临时目录
    local tmp_dir="$FILE_SESSION_WORKDIR/session_$(date +%s%n)_$$"
    mkdir -p "$tmp_dir" 2>/dev/null
    if [ $? -ne 0 ]; then
        log "ERROR" "无法创建临时目录: $tmp_dir"
        color_red "无法创建临时目录" >&2
        return 1
    fi
    
    local input_file="$tmp_dir/input.txt"
    local output_file="$tmp_dir/output.txt"
    
    # 写入命令
    printf '%s' "$command" > "$input_file" 2>/dev/null
    if [ $? -ne 0 ]; then
        log "ERROR" "无法写入命令文件: $input_file"
        color_red "无法写入命令文件" >&2
        rm -rf "$tmp_dir" 2>/dev/null
        return 1
    fi
    
    log "DEBUG" "输入文件: $input_file, 输出文件: $output_file"
    
    # 调用服务
    local service_cmd="service call $SERVICE_NAME $TRANSACTION_EXECUTE_FILE s16 \"FILE:$input_file:$output_file\""
    log "DEBUG" "执行: $service_cmd"
    
    # 执行服务调用
    eval "$service_cmd" >/dev/null 2>&1; local exit_code=$?
    
    if [ "$exit_code" -eq 0 ]; then
        # 等待输出文件
        local max_wait=30
        local waited=0
        
        while [ $waited -lt $max_wait ]; do
            if [ -f "$output_file" ] && [ -s "$output_file" ]; then
                # 读取并显示输出
                cat "$output_file"
                local result=$?
                
                # 清理
                rm -rf "$tmp_dir" 2>/dev/null
                return $result
            fi
            sleep 0.5
            waited=$((waited + 1))
        done
        
        color_yellow "命令执行超时" >&2
    else
        log "ERROR" "服务调用失败 (代码: $exit_code)"
        color_red "服务调用失败 (代码: $exit_code)" >&2
    fi
    
    # 清理
    rm -rf "$tmp_dir" 2>/dev/null
    return 1
}

# 执行文件中的命令
execute_from_file() {
    local file_path="$1"
    log "DEBUG" "从文件执行命令: $file_path"
    
    if [ ! -f "$file_path" ]; then
        log "ERROR" "文件不存在: $file_path"
        color_red "文件不存在: $file_path" >&2
        return 1
    fi
    
    if [ ! -r "$file_path" ]; then
        log "ERROR" "无法读取文件: $file_path"
        color_red "无法读取文件: $file_path" >&2
        return 1
    fi
    
    # 读取文件内容
    local command
    command=$(cat "$file_path" 2>/dev/null)
    
    if [ -z "$command" ]; then
        color_yellow "文件为空" >&2
        return 1
    fi
    
    log "DEBUG" "文件内容: $command"
    
    # 根据模式执行
    if [ "$MODE" = "socket" ] && check_java_client; then
        color_cyan "[使用Java客户端套接字模式执行文件命令]" >&2
        execute_java_client "socket" "$command"
    elif [ "$MODE" = "file" ] && check_java_client; then
        color_cyan "[使用Java客户端文件模式执行文件命令]" >&2
        execute_java_client "file" "$command"
    else
        color_cyan "[使用文件模式执行文件命令]" >&2
        execute_file_mode "$command"
    fi
}

# 交互式终端模式
start_interactive_terminal() {
    log "INFO" "启动交互式终端"
    
    # 显示欢迎信息
    clear
    color_cyan "╔══════════════════════════════════════════════════════╗"
    color_cyan "║      Xposed Method CLI - 交互式终端 v$VERSION           ║"
    color_cyan "╠══════════════════════════════════════════════════════╣"
    color_cyan "║                                                      ║"
    echo -e "${CYAN}║  ${GREEN}输入命令直接执行，支持以下操作：${CYAN}                    ║"
    color_cyan "║                                                      ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}invoke   - 调用方法                               ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}list     - 列出方法                               ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}bsh      - 执行BeanShell代码                      ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}script   - 执行脚本代码                           ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}packages - 列出包名                               ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}help     - 显示帮助, 查看服务端支持的更多命令     ║"
    color_cyan "║                                                      ║"
    echo -e "${CYAN}║  ${YELLOW}终端命令：${CYAN}                                          ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}exit/quit      - 退出终端                         ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}clear          - 清屏                             ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}history        - 显示历史命令                     ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}clear_history  - 清除历史命令                     ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}mode           - 切换执行模式                     ║"
    echo -e "${CYAN}║  ${YELLOW}• ${CYAN}debug          - 切换调试模式                     ║"
    color_cyan "║                                                      ║"
    color_cyan "╚══════════════════════════════════════════════════════╝"
    echo
    color_green "当前模式: $INTERACTIVE_MODE"
    if [ -f "$JAVA_CLIENT_JAR" ]; then
        color_green "Java客户端: 已安装"
    else
        color_green "Java客户端: 未安装"
    fi
    if [ "$DEBUG" = "1" ]; then
        color_green "调试模式: 开启"
    else
        color_green "调试模式: 关闭"
    fi
    echo
    color_yellow "提示: 输入 'help_interactive' 查看交互终端详细帮助，'exit' 退出终端"
    echo
    
    # 初始化历史
    local history_file="$METHODS_WORKDIR/methods_history"
    
    # 主循环
    while true; do
        # 显示提示符
        echo -n -e "${GREEN}methods(${INTERACTIVE_MODE})> ${NC}"
        
        # 读取输入
        local input
        if ! read -r input; then
            echo
            break
        fi
        
        # 添加到历史
        if [ -n "$input" ]; then
            echo "$input" >> "$history_file"
        fi
        
        # 处理空输入
        if [ -z "$input" ]; then
            continue
        fi
        
        # 处理终端命令
        case "$input" in
            exit|quit)
                color_cyan "再见！"
                break
                ;;
            clear)
                clear
                continue
                ;;
            history)
                color_cyan "历史命令:"
                if [ -f "$history_file" ]; then
                    local line_num=1
                    while IFS= read -r line; do
                        echo "  $line_num. $line"
                        line_num=$((line_num + 1))
                    done < "$history_file"
                else
                    echo "  无历史记录"
                fi
                continue
                ;;
            clear_history)
                rm -f "$history_file" 2>/dev/null
                color_green "历史记录已清除"
                continue
                ;;
            mode)
                if [ "$INTERACTIVE_MODE" = "socket" ]; then
                    INTERACTIVE_MODE="file"
                    color_green "切换到文件模式"
                else
                    if [ -f "$JAVA_CLIENT_JAR" ]; then
                        INTERACTIVE_MODE="socket"
                        color_green "切换到套接字模式"
                    else
                        INTERACTIVE_MODE="file"
                        color_yellow "Java客户端不可用，使用文件模式"
                    fi
                fi
                continue
                ;;
            debug)
                if [ "$DEBUG" = "1" ]; then
                    DEBUG="0"
                    color_green "调试模式已关闭"
                else
                    DEBUG="1"
                    color_green "调试模式已开启"
                fi
                continue
                ;;
            help_interactive)
                echo "终端命令:"
                echo "  exit/quit  - 退出终端"
                echo "  clear      - 清屏"
                echo "  history    - 显示历史命令"
                echo "  mode       - 切换执行模式 (当前: $INTERACTIVE_MODE)"
                if [ "$DEBUG" = "1" ]; then
                    echo "  debug      - 切换调试模式 (当前: 开启)"
                else
                    echo "  debug      - 切换调试模式 (当前: 关闭)"
                fi
                echo
                echo "模块命令:"
                echo "  help        - 显示模块帮助"
                echo "  invoke      - 调用方法"
                echo "  list        - 列出方法"
                echo "  bsh         - 执行BeanShell代码"
                echo "  script      - 执行脚本代码"
                echo "  packages    - 列出包名"
                echo "  ...其他模块支持的命令, 可以通过help获得服务端帮助"
                continue
                ;;
        esac
        
        # 记录日志
        log "INFO" "交互式命令: $input"
        
        # 根据当前模式执行命令
        local start_time=$(date +%s)
        
        if [ "$INTERACTIVE_MODE" = "socket" ] && [ -f "$JAVA_CLIENT_JAR" ]; then
            execute_java_client "socket" "$input"
        else
            execute_file_mode "$input"
        fi
        
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        
        # 显示执行时间（如果超过1秒）
        if [ $duration -gt 1 ]; then
            color_cyan "执行时间: ${duration}秒"
        fi
        
        echo
    done
    
    # 清理历史文件（保留最近100行）
    if [ -f "$history_file" ]; then
        tail -n 100 "$history_file" > "${history_file}.tmp"
        mv "${history_file}.tmp" "$history_file"
    fi
    
    log "INFO" "交互式终端结束"
}

# 套接字模式（使用Java客户端）
execute_socket_mode() {
    local command="$*"
    log "INFO" "套接字模式执行: $command"
    
    if [ -f "$JAVA_CLIENT_JAR" ]; then
        log "DEBUG" "使用Java客户端套接字模式" 
        
        execute_java_client "socket" "$command"
        return $?
    else
        log "WARN" "Java客户端不可用，降级为文件模式"
        execute_file_mode "$command"
        return $?
    fi
}

# Java文件模式
execute_java_file() {
    local command="$*"
    log "INFO" "Java文件模式执行: $command"
    
    if [ -f "$JAVA_CLIENT_JAR" ]; then
        color_cyan "[使用Java文件模式]" >&2
        execute_java_client "file" "$command"
        return $?
    else
        color_yellow "[Java客户端不可用，使用文件模式]" >&2
        execute_file_mode "$command"
        return $?
    fi
}



# 导出上下文功能
export_context() {
    log "INFO" "导出设备上下文"
    
    # 创建临时输出文件
    local tmp_dir="$PORT_UPDATE_SESSION_WORKDIR/session_$(date +%s%n)_$$"
    mkdir -p "$tmp_dir" 2>/dev/null
    if [ $? -ne 0 ]; then
        log "ERROR" "无法创建临时目录"
        color_red "无法创建临时目录" >&2
        return 1
    fi
    
    local output_file="$tmp_dir/result.txt"
    
    log "DEBUG" "使用事务码${TRANSACTION_EXPORT_CONTEXT}导出上下文"
    log "DEBUG" "输出文件: $output_file"
    
    # 调用服务
    local service_cmd="service call $SERVICE_NAME $TRANSACTION_EXPORT_CONTEXT s16 $output_file"
    log "DEBUG" "执行: $service_cmd"
    
    # 执行服务调用
    eval "$service_cmd" >/dev/null 2>&1; local exit_code=$?
    
    if [ "$exit_code" -eq 0 ]; then
        # 等待输出文件
        local max_wait=10
        local waited=0
        
        while [ $waited -lt $max_wait ]; do
            if [ -f "$output_file" ] && [ -s "$output_file" ]; then
                # 读取并显示输出
                log "INFO" "上下文导出结果:"
                cat "$output_file"
                local result=$?
                
                # 清理
                rm -rf "$tmp_dir" 2>/dev/null
                return $result
            fi
            sleep 0.5
            waited=$((waited + 1))
        done
        
        color_yellow "上下文导出操作超时" >&2
    else
        log "ERROR" "上下文导出服务调用失败 (代码: $exit_code)"
        color_red "服务调用失败 (代码: $exit_code)" >&2
    fi
    
    # 清理
    rm -rf "$tmp_dir" 2>/dev/null
    return 1
}


# 更新端口功能
update_port() {
    local port="$1"
    log "INFO" "更新端口: $port"
    
    # 创建临时输出文件
    local tmp_dir="$PORT_UPDATE_SESSION_WORKDIR/session_$(date +%s%n)_$$"
    mkdir -p "$tmp_dir" 2>/dev/null
    if [ $? -ne 0 ]; then
        log "ERROR" "无法创建临时目录"
        color_red "无法创建临时目录" >&2
        return 1
    fi
    
    local output_file="$tmp_dir/result.txt"
    
    log "DEBUG" "使用事务码${TRANSACTION_UPDATE_PORT}更新端口"
    log "DEBUG" "端口: $port, 输出文件: $output_file"
    
    # 调用服务
    local service_cmd="service call $SERVICE_NAME $TRANSACTION_UPDATE_PORT i32 $port s16 $output_file"
    log "DEBUG" "执行: $service_cmd"
    
    # 执行服务调用
    eval "$service_cmd" >/dev/null 2>&1
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        # 等待输出文件
        local max_wait=10
        local waited=0
        
        while [ $waited -lt $max_wait ]; do
            if [ -f "$output_file" ] && [ -s "$output_file" ]; then
                # 读取并显示输出
                log "INFO" "端口更新结果:"
                cat "$output_file"
                local result=$?
                
                # 清理
                rm -rf "$tmp_dir" 2>/dev/null
                return $result
            fi
            sleep 0.5
            waited=$((waited + 1))
        done
        
        color_yellow "端口更新操作超时" >&2
    else
        log "ERROR" "端口更新服务调用失败 (代码: $exit_code)"
        color_red "服务调用失败 (代码: $exit_code)" >&2
    fi
    
    # 清理
    rm -rf "$tmp_dir" 2>/dev/null
    return 1
}


# 检查当前端口
check_current_port() {
    local port_file="$SERVER_PORT_FILE"
    if [ -f "$port_file" ]; then
        local port=$(cat "$port_file" 2>/dev/null | head -1 | tr -d '\n\r ')
        if [ -n "$port" ]; then
            echo "当前端口: $port"
            log "INFO" "当前端口: $port"
            return 0
        fi
    fi
    echo "端口文件不存在或为空"
    return 1
}


# 显示帮助
show_help() {
    echo "${CYAN}Xposed Method CLI Shell 客户端 v${VERSION}${NC}"
    echo "作者: ${GREEN}JustNothing 和 DeepSeek(?) ${NC}"
    echo ""
    echo "${YELLOW}用法:${NC}"
    echo "  methods [选项] <命令>"
    echo ""
    echo "${YELLOW}选项:${NC}"
    echo "  ${GREEN}-h, --client-help${NC}    显示此帮助信息"
    echo "  ${GREEN}-v, --version${NC}        显示版本信息"
    echo "  ${GREEN}-d, --debug${NC}          启用调试模式"
    echo "  ${GREEN}-c, --check${NC}          检查服务状态"
    echo "  ${GREEN}-s, --socket${NC}         使用套接字模式（默认）"
    echo "  ${GREEN}-f, --file${NC}           使用文件模式（无长度限制）"
    echo "  ${GREEN}-i, --interactive${NC}    启动交互式终端"
    echo "  ${GREEN}--exec-file <文件>${NC}   从文件读取并执行命令"
    echo "  ${GREEN}--current-port${NC}       获取当前服务器的端口"
    echo "  ${GREEN}--update-port <端口>${NC} 更新Socket服务器端口，会重启Socket服务端"
    echo "  ${GREEN}--export-context${NC}     导出设备的XTChttp上下文，Json格式，搭配xtchttplib使用"
    echo "  ${GREEN}-j, --java-client${NC}    使用Java客户端直接执行命令（传递所有后续参数给Java客户端）"
    echo "  ${GREEN}--${NC}                   将所有后续参数直接传给服务端（绕过客户端选项解析）"
    echo ""
    echo "${YELLOW}参数解析机制:${NC}"
    echo "  1. 客户端选项（如 -h, -v, -d, -c, -s, -f, -i, -j 等）会被客户端处理"
    echo "  2. 遇到第一个无法识别的参数时，该参数及后续所有参数会自动传给服务端"
    echo "  3. 使用 ${GREEN}--${NC} 可以显式指定后续参数都传给服务端"
    echo ""
    echo "${YELLOW}执行模式说明:${NC}"
    echo "  ${GREEN}Java套接字模式${NC}  - 使用Java客户端，实时输出 (通过app_process执行，性能开销较大但体验好)"
    echo "  ${GREEN}Java文件模式${NC}    - 使用Java客户端，通过文件缓存，一次性输出 (测试用, 不是很建议)"
    echo "  ${GREEN}文件模式${NC}        - 纯Shell实现，通过文件通信不用调用Java客户端，一次性输出，适用于短时间执行需求"
    echo "  ${GREEN}交互式终端${NC}      - 持续输入命令的终端界面"
    echo "  ${GREEN}Java客户端直连${NC}  - 使用 -j 选项，直接传递所有参数给Java客户端"
    echo ""
    echo "${YELLOW}Java客户端路径:${NC}"
    echo "  $JAVA_CLIENT_JAR"
    if [ -f "$JAVA_CLIENT_JAR" ]; then
        echo "  ${GREEN}(已找到)${NC}"
    else
        echo "  ${RED}(未找到，请检查模块安装是否正确)${NC}"
    fi
    echo ""
    echo "${YELLOW}示例:${NC}"
    echo "  ${BLUE}methods help${NC}                                                    # 显示服务端帮助"
    echo "  ${BLUE}methods -f invoke java.lang.System currentTimeMillis${NC}            # 调用静态方法 (详情见服务端帮助)"
    echo "  ${BLUE}methods script 'for (int i = 0; i < 114; i++) println(i); '${NC}     # 执行脚本 (详情见服务端帮助)"
    echo "  ${BLUE}methods --exec-file /sdcard/command.txt${NC}                         # 执行文件中的命令"
    echo "  ${BLUE}methods --interactive${NC}                                           # 启动交互式终端"
    echo "  ${BLUE}methods -d -- list -v java.lang.String ${NC}                         # 查看String类的所有方法，同时展示客户端debug信息"
    echo "  ${BLUE}methods -j --help${NC}                                               # 查看Java客户端的帮助"
    echo "  ${BLUE}methods -j --file packages${NC}                                      # 使用Java客户端的文件模式 (不建议)"
    echo ""
    echo ""
    echo "${YELLOW}交互式终端命令:${NC}"
    echo "  ${GREEN}help${NC}      - 显示终端帮助"
    echo "  ${GREEN}exit/quit${NC} - 退出终端"
    echo "  ${GREEN}clear${NC}     - 清屏"
    echo "  ${GREEN}history${NC}   - 显示历史"
    echo "  ${GREEN}mode${NC}      - 切换执行模式"
    echo "  ${GREEN}debug${NC}     - 切换调试模式"
    echo ""
    echo "${YELLOW}提示:${NC}"
    echo "  • 默认使用Java套接字模式，需要安装Java客户端"
    echo "  • 使用 ${GREEN}-d${NC} 选项查看详细调试信息"
    echo "  • 使用 ${GREEN}-f${NC} 选项使用文件模式，执行更快速，开销小"
    echo "  • 使用 ${GREEN}-j${NC} 选项直接调用Java客户端，传递所有后续参数"
}

# 显示版本
show_version() {
    color_cyan "Xposed Method CLI Shell 客户端 v${VERSION}"
    echo "当前时间: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "服务名称: $SERVICE_NAME"
    echo "Java客户端: $JAVA_CLIENT_JAR"
    
    if check_service; then
        color_green "✓ 服务状态: 正常"
    else
        log "WARN" "服务状态异常"
        color_red "服务状态: 异常"
    fi
    
    if [ -f "$JAVA_CLIENT_JAR" ]; then
        color_green "✓ Java客户端: 已安装"
        # 尝试获取JAR文件信息
        if command -v stat >/dev/null 2>&1; then
            local jar_size=$(stat -c%s "$JAVA_CLIENT_JAR" 2>/dev/null || echo "未知")
            local jar_mtime=$(stat -c%y "$JAVA_CLIENT_JAR" 2>/dev/null || echo "未知")
            echo "  文件大小: $jar_size 字节"
            echo "  修改时间: $jar_mtime"
        else
            echo "  文件信息: 无法获取"
        fi
    else
        log "WARN" "Java客户端未安装"
        color_yellow "⚠ Java客户端: 未安装（某些功能受限）"
    fi
}

# 主函数
main() {
    # 默认值
    MODE="auto"
    INTERACTIVE_MODE="socket"
    local check_only=0
    local exec_file=""
    local command=""
    local use_java_client=0
    local update_port=""
    local show_current_port=0
    local export_context=0
    
    # 如果没有参数，显示帮助
    if [ $# -eq 0 ]; then
        show_help
        return 0
    fi
    
    # 解析参数
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--client-help)
                show_help
                return 0
                ;;
            -v|--version)
                show_version
                return 0
                ;;
            -d|--debug)
                DEBUG=1
                shift
                ;;
            -c|--check)
                check_only=1
                shift
                ;;
            -s|--socket)
                MODE="socket"
                shift
                ;;
            -f|--file)
                MODE="file"
                shift
                ;;
            -i|--interactive)
                MODE="interactive"
                shift
                ;;
            -j|--java-client)
                use_java_client=1
                shift
                execute_java_client_direct "$@"
                return $?
                ;;
            --exec-file)
                if [ $# -gt 1 ]; then
                    exec_file="$2"
                    shift 2
                else
                    color_red "错误: --exec-file 需要文件路径参数" >&2
                    return 1
                fi
                ;;
            --update-port)
                if [ $# -gt 1 ]; then
                    update_port="$2"
                    shift 2
                else
                    color_red "错误: --update-port 需要端口号参数" >&2
                    return 1
                fi
                ;;
            --current-port)
                show_current_port=1
                shift
                ;;
            --export-context)
                export_context=1
                shift
                ;;
            --)
                shift
                command="$*"
                log "INFO" "遇到 -- 分隔符，将后续所有参数传给服务端: $command"
                break
                ;;
            *)
                # 遇到第一个无法识别的参数，将其及后续所有参数作为命令传给服务端
                command="$*"
                log "INFO" "遇到无法识别的参数，将当前及后续所有参数传给服务端: $command"
                break
                ;;
        esac
    done
    
    # 检查服务（除非是纯Java客户端模式）
    if [ $use_java_client -eq 0 ] && [ -z "$update_port" ] && ! check_service; then
        color_red "错误: 无法连接到Xposed模块" >&2
        echo
        color_yellow "请确保:" >&2
        color_yellow "  模块已安装并激活" >&2
        color_yellow "  已重启设备" >&2
        color_yellow "  服务名称为: $SERVICE_NAME" >&2
        return 1
    fi
    
    # 显示当前端口
    if [ $show_current_port -eq 1 ]; then
        check_current_port
        return $?
    fi
    
    # 导出上下文
    if [ $export_context -eq 1 ]; then
        export_context
        return $?
    fi
    
    if [ $check_only -eq 1 ]; then
        show_version
        return 0
    fi
    
    # 更新端口
    if [ -n "$update_port" ]; then
        # 验证端口号
        
        if ! expr "$update_port" : '[0-9]*$' >/dev/null; then
            color_red "错误: 端口号必须是数字" >&2
            return 1
        fi
        
        if [ "$update_port" -lt 1024 ] || [ "$update_port" -gt 65535 ]; then
            color_red "错误: 端口号必须在1024-65535范围内" >&2
            return 1
        fi
        
        update_port "$update_port"
        return $?
    fi
    
    
    # 执行文件模式
    if [ -n "$exec_file" ]; then
        execute_from_file "$exec_file"
        return $?
    fi
    
    # 交互式模式
    if [ "$MODE" = "interactive" ]; then
        # 设置交互式模式的默认执行方式
        if [ -f "$JAVA_CLIENT_JAR" ]; then
            INTERACTIVE_MODE="socket"
        else
            INTERACTIVE_MODE="file"
            color_yellow "Java客户端不可用，交互式模式使用文件模式"
        fi
        
        start_interactive_terminal
        return 0
    fi
    
    # 如果没有命令，进入交互式模式
    if [ -z "$command" ]; then
        color_yellow "没有提供命令，进入交互式模式..."
        MODE="interactive"
        start_interactive_terminal
        return 0
    fi
    
    # 根据模式执行命令
    case "$MODE" in
        socket)
            execute_socket_mode "$command"
            ;;
        file)
            execute_file_mode "$command"
            ;;
        auto)
            # 自动选择模式
            if [ -f "$JAVA_CLIENT_JAR" ]; then
                execute_socket_mode "$command"
            else
                execute_file_mode "$command"
            fi
            ;;
        *)
            color_red "未知模式: $MODE" >&2
            return 1
            ;;
    esac
}

# 清理函数
cleanup() {
    # 清理临时文件
    find "$METHODS_WORKDIR/execute_sessions" -name "methods_*" -type d -mmin +10 2>/dev/null | xargs rm -rf 2>/dev/null
    find "$METHODS_WORKDIR/" -name "methods_*.txt" -mmin +10 2>/dev/null | xargs rm -f 2>/dev/null
}

# 设置退出时清理
trap cleanup EXIT

# 运行主函数
main "$@"
exit $?